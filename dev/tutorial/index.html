<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · GaussianRandomFields.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://PieterjanRobbe.github.io/GaussianRandomFields.jl/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GaussianRandomFields.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GaussianRandomFields.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Table-of-Contents"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#Package-Overview"><span>Package Overview</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Gaussian-Random-Field-Generators"><span>Gaussian Random Field Generators</span></a></li><li><a class="tocitem" href="#Defining-Custom-Covariance-Functions"><span>Defining Custom Covariance Functions</span></a></li><li><a class="tocitem" href="#Importing-Covariance-Functions-from-KernelFunctions.jl"><span>Importing Covariance Functions from <code>KernelFunctions.jl</code></span></a></li><li><a class="tocitem" href="#Unstructured-Grids"><span>Unstructured Grids</span></a></li><li><a class="tocitem" href="#More-dimensional-Random-Fields"><span>More-dimensional Random Fields</span></a></li><li><a class="tocitem" href="#Separable-Random-Fields"><span>Separable Random Fields</span></a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PieterjanRobbe/GaussianRandomFields.jl/blob/main/docs/src/tutorial.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial contains some examples on how to use <code>GaussianRandomFields</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Don&#39;t forget to import <code>GaussianRandomFields</code> and <code>Plots</code> before running the examples below:</p><pre><code class="language-julia hljs">using GaussianRandomFields
using Plots</code></pre></div></div><h2 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h2><ul><li><a href="#Tutorial">Tutorial</a></li><li class="no-marker"><ul><li><a href="#Table-of-Contents">Table of Contents</a></li><li><a href="#Package-Overview">Package Overview</a></li><li><a href="#Examples">Examples</a></li><li class="no-marker"><ul><li><a href="#D-Exponential-Covariance-Function">1D Exponential Covariance Function</a></li><li><a href="#D-Matérn-Covariance-Function">2D Matérn Covariance Function</a></li><li><a href="#D-Anisotropic-Covariance-Function">2D Anisotropic Covariance Function</a></li></ul></li><li><a href="#Gaussian-Random-Field-Generators">Gaussian Random Field Generators</a></li><li class="no-marker"><ul><li><a href="#Cholesky-Factorization">Cholesky Factorization</a></li><li><a href="#Eigenvalue-Decomposition">Eigenvalue Decomposition</a></li><li><a href="#Karhunen-Loève-Expansion">Karhunen-Loève Expansion</a></li><li><a href="#Circulant-Embedding">Circulant Embedding</a></li></ul></li><li><a href="#Defining-Custom-Covariance-Functions">Defining Custom Covariance Functions</a></li><li><a href="#Importing-Covariance-Functions-from-KernelFunctions.jl">Importing Covariance Functions from <code>KernelFunctions.jl</code></a></li><li><a href="#Unstructured-Grids">Unstructured Grids</a></li><li class="no-marker"><ul><li><a href="#An-L-shape">An L-shape</a></li></ul></li><li><a href="#More-dimensional-Random-Fields">More-dimensional Random Fields</a></li><li><a href="#Separable-Random-Fields">Separable Random Fields</a></li></ul></li></ul><p>A Gaussian random field is a function that describes a random quantity at each point in space. Below are three example realizations of a Gaussian random field with exponential covariance.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, Exponential(.5))
pts = range(0, stop=1, length=1001)
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, minpadding=2001)
heatmap(grf)</code></pre><img src="assets/exponential_grf.jpg" alt="exponential_grf" style="width:100%"><h2 id="Package-Overview"><a class="docs-heading-anchor" href="#Package-Overview">Package Overview</a><a id="Package-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Overview" title="Permalink"></a></h2><p>This package offers support to generate and sample from Gaussian random fields. Gaussian random fields can be classified as follows.</p><p align="center">
<img src="assets/classification.png" alt="classification" style="width:75%" align="middle">
</p><p>We offer support for stationary separable random fields and stationary non-separable isotropic and anisotropic random fields. This includes isotropic random fields with commonly used covariance functions, such as the exponential, Matérn, Whittle and Gaussian kernel, and anisotropic random fields, such as the anisotropic exponential kernel and the rotated anisotropic Matérn kernel. The Gaussian random fields can be defined on a rectangular structured grid, or on a Finite Element triangular unstructured mesh. </p><p>The basic syntax is as follows.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(d, Kernel()) # covariance function in d dimensions with kernel Kernel()
pts_x = range(a, stop=b, length=n) # structured grid (see below for unstructured grids)
pts_y = range(a, stop=b, length=n) # ... (d times)
grf = GaussianRandomField(cov, Generator(), pts_x, pts_y) # Gaussian random field with generator Generator()
sample(grf) # take a sample of the Gaussian random field</code></pre><p>In these expressions, <code>Kernel()</code> must be replaced by a call to either a predefined covariance kernel, or to a user-defined kernel. Here&#39;s a list of predefined kernels:</p><ul><li>exponential kernel, see <a href="../API/#GaussianRandomFields.Exponential"><code>Exponential</code></a></li><li>linear (or triangular) kernel, see <a href="../API/#GaussianRandomFields.Linear"><code>Linear</code></a></li><li>spherical kernel, see <a href="../API/#GaussianRandomFields.Spherical"><code>Spherical</code></a></li><li>Whittle kernel, see <a href="../API/#GaussianRandomFields.Whittle"><code>Whittle</code></a></li><li>Gaussian (or squared exponential) kernel, see <a href="../API/#GaussianRandomFields.Gaussian"><code>Gaussian</code></a></li><li>Matérn kernel, see <a href="../API/#GaussianRandomFields.Matern"><code>Matern</code></a></li><li>anisotropic exponential kernel, see <a href="../API/#GaussianRandomFields.AnisotropicExponential"><code>AnisotropicExponential</code></a></li></ul><p>The Gaussian random field generator <code>Generator()</code> must be replaced by a call to a predefined Gaussian random field generator:</p><ul><li>a Cholesky factorization of the covariance matrix, see <a href="../API/#GaussianRandomFields.Cholesky"><code>Cholesky</code></a></li><li>an eigenvalue decomposition of the covariance matrix, see <a href="../API/#GaussianRandomFields.Spectral"><code>Spectral</code></a></li><li>a truncated Karhunen-Loève expansion, see <a href="../API/#GaussianRandomFields.KarhunenLoeve"><code>KarhunenLoeve</code></a></li><li>a circulant embedding, see <a href="../API/#GaussianRandomFields.CirculantEmbedding"><code>CirculantEmbedding</code></a></li></ul><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Let&#39;s first look at some examples.</p><h3 id="D-Exponential-Covariance-Function"><a class="docs-heading-anchor" href="#D-Exponential-Covariance-Function">1D Exponential Covariance Function</a><a id="D-Exponential-Covariance-Function-1"></a><a class="docs-heading-anchor-permalink" href="#D-Exponential-Covariance-Function" title="Permalink"></a></h3><p>As a first example, consider the exponential covariance kernel, defined as</p><p class="math-container">\[C(x, y) = σ \exp\left(-\displaystyle\frac{ρ}{λ}\right)\]</p><p>with <span>$ρ = ||x - y||_p$</span>, and where λ is a length scale.</p><pre><code class="language-julia hljs">exponential = Exponential(0.1) # 0.1 is the length scale λ</code></pre><p>Let&#39;s define a one-dimensional exponential covariance function.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(1, exponential) # 1 is the number of dimensions.</code></pre><p>Now, suppose the Gaussian process is defined on <code>[0, 1]</code>.</p><pre><code class="language-julia hljs">pts = range(0, stop=1, length=1001) # 1001 is the number of points</code></pre><p>Here&#39;s how to compute the Gaussian process with exponential covariance function <code>cov</code> defined in the points <code>pts</code>.</p><pre><code class="language-julia hljs">grf = GaussianRandomField(cov, Cholesky(), pts)</code></pre><p>Here are some samples of the random field.</p><pre><code class="language-julia hljs">plot(grf)
plot!(grf)
plot!(grf)</code></pre><img src="assets/1d_exponential.jpg" alt="1d_exponential" style="width:100%"><p>See also: <a href="../API/#GaussianRandomFields.Exponential"><code>Exponential</code></a>, <a href="../API/#GaussianRandomFields.CovarianceFunction"><code>CovarianceFunction</code></a>, <a href="../API/#GaussianRandomFields.GaussianRandomField"><code>GaussianRandomField</code></a>, <a href="../API/#GaussianRandomFields.Cholesky"><code>Cholesky</code></a></p><h3 id="D-Matérn-Covariance-Function"><a class="docs-heading-anchor" href="#D-Matérn-Covariance-Function">2D Matérn Covariance Function</a><a id="D-Matérn-Covariance-Function-1"></a><a class="docs-heading-anchor-permalink" href="#D-Matérn-Covariance-Function" title="Permalink"></a></h3><p>In this second example, we switch from random processes (<code>d=1</code>) to random fields (<code>d&gt;1</code>). A well-known stationary isotropic covariance kernel is the Matérn covariance kernel</p><p class="math-container">\[C(x, y) = σ \frac{2^{1 - ν}}{Γ(ν)} \left(\frac{ρ}{λ}\right)^ν K_ν\left(\frac{ρ}{λ}\right)\]</p><p>with <span>$ρ = ||x - y||_p$</span>, where λ is a length scale and ν is the smoothness.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, Matern(1/4, 3/4)) # length scale 1/4, smoothness 3/4</code></pre><p>We generate samples of this random field on a regular grid with grid spacing <code>1/400</code> using circulant embedding. This is a fast and exact sampling method that uses an FFT.</p><pre><code class="language-julia hljs">pts = range(0, stop=1, step=1/400)
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, minpadding=113)
heatmap(grf)</code></pre><img src="assets/2d_matern.jpg" alt="2d_matern" style="width:100%"><p>Here is a visual comparison of the random field with a decreasing smoothness parameter ν.</p><pre><code class="language-julia hljs">for ν in [5/4, 1, 7/8, 3/4, 5/8, 1/2]
    cov = CovarianceFunction(2, Matern(1/4, ν))
    grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, minpadding=625)
    heatmap(grf)
end</code></pre><img src="assets/matern_smoothness.jpg" alt="matern_smoothness" style="width:100%"><p>See also: <a href="../API/#GaussianRandomFields.Matern"><code>Matern</code></a>, <a href="../API/#GaussianRandomFields.CovarianceFunction"><code>CovarianceFunction</code></a>, <a href="../API/#GaussianRandomFields.GaussianRandomField"><code>GaussianRandomField</code></a>, <a href="../API/#GaussianRandomFields.CirculantEmbedding"><code>CirculantEmbedding</code></a></p><h3 id="D-Anisotropic-Covariance-Function"><a class="docs-heading-anchor" href="#D-Anisotropic-Covariance-Function">2D Anisotropic Covariance Function</a><a id="D-Anisotropic-Covariance-Function-1"></a><a class="docs-heading-anchor-permalink" href="#D-Anisotropic-Covariance-Function" title="Permalink"></a></h3><p>In the last example, we focus on anisotropic random fields. These random fields behave differently in different directions. For example, the anisotropic exponential covariance kernel is defined as</p><p class="math-container">\[C(x, y) = \exp(-ρᵀ A ρ)\]</p><p>where <span>$ρ = x - y$</span> and <span>$A$</span> is a positive definite matrix.</p><pre><code class="language-julia hljs">A = [1000 800; 800 1000]
cov = CovarianceFunction(2, AnisotropicExponential(A))</code></pre><p>Here are some samples of this random field.</p><img src="assets/anisotropic.jpg" alt="anisotropic" style="width:100%"><p>See also: <a href="../API/#GaussianRandomFields.AnisotropicExponential"><code>AnisotropicExponential</code></a>, <a href="../API/#GaussianRandomFields.CovarianceFunction"><code>CovarianceFunction</code></a>, <a href="../API/#GaussianRandomFields.GaussianRandomField"><code>GaussianRandomField</code></a>, <a href="../API/#GaussianRandomFields.KarhunenLoeve"><code>KarhunenLoeve</code></a></p><h2 id="Gaussian-Random-Field-Generators"><a class="docs-heading-anchor" href="#Gaussian-Random-Field-Generators">Gaussian Random Field Generators</a><a id="Gaussian-Random-Field-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Random-Field-Generators" title="Permalink"></a></h2><p>Different methods for generating Gaussian random fields are available: <code>Cholesky()</code>, <code>Spectral()</code>, <code>KarhunenLoeve(n)</code> and <code>CirculantEmbedding</code>. We will briefly discuss these below. </p><h3 id="Cholesky-Factorization"><a class="docs-heading-anchor" href="#Cholesky-Factorization">Cholesky Factorization</a><a id="Cholesky-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Cholesky-Factorization" title="Permalink"></a></h3><p>A Gaussian random field generator based on the Cholesky factorization of the covariance matrix.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, Matern(1/2, 5/4))
pts = range(0, stop=1, length=101)
grf = GaussianRandomField(cov, Cholesky(), pts, pts)
contourf(grf)</code></pre><img src="assets/cholesky.jpg" alt="cholesky" style="width:100%"><p>If more points are used, and especially in higher dimensions, computing the Choleksy factorization becomes too expensive. Furthermore, the expansion can only be computed when the covariance matrix is symmetric positive definite (SPD). If this is not the case, try using <code>Spectral()</code> instead.</p><p>See <a href="../API/#GaussianRandomFields.Cholesky"><code>Cholesky</code></a> for more.</p><h3 id="Eigenvalue-Decomposition"><a class="docs-heading-anchor" href="#Eigenvalue-Decomposition">Eigenvalue Decomposition</a><a id="Eigenvalue-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-Decomposition" title="Permalink"></a></h3><p>A Gaussian random field generator based on the eigenvalue decomposition of the covariance matrix.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, Linear(1))
pts = range(0, stop=1, length=51)
grf = GaussianRandomField(cov, Spectral(), pts, pts)
contourf(grf)</code></pre><img src="assets/spectral.jpg" alt="spectral" style="width:100%"><p>See <a href="../API/#GaussianRandomFields.Spectral"><code>Spectral</code></a> for more.</p><h3 id="Karhunen-Loève-Expansion"><a class="docs-heading-anchor" href="#Karhunen-Loève-Expansion">Karhunen-Loève Expansion</a><a id="Karhunen-Loève-Expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Karhunen-Loève-Expansion" title="Permalink"></a></h3><p>A Gaussian random field generator using a truncated Karhunen-Loève expansion with <code>n</code> terms.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, Whittle(.1))
pts = range(0, stop=1, length=201)
grf = GaussianRandomField(cov, KarhunenLoeve(500), pts, pts)
heatmap(grf)</code></pre><img src="assets/karhunen_loeve.jpg" alt="karhunen_loeve" style="width:100%"><p>The KL expansion uses a linear combination of eigenfunctions of the covariance operator, where the weights are determined by the magnitude of the eigenvalues.</p><pre><code class="language-julia hljs">plot_eigenvalues(grf)
plot_eigenfunction(grf, n) # n is eigenfunction number 1, 2, ..., 6</code></pre><img src="assets/eigenvalues.png" alt="eigenvalues" style="width:100%"><img src="assets/eigenfunctions.jpg" alt="eigenfunctions" style="width:100%"><p>Adding more terms to the expansion increases the approximation of the Gaussian random field.</p><pre><code class="language-julia hljs">for n in [1 2 5 10 20 50 100 200 500 1000]
    grf = GaussianRandomField(cov, KarhunenLoeve(n), pts, pts)
    @printf(&quot; n = %4d | error = %0.4f\n&quot;, n, rel_error(grf))
end</code></pre><pre><code class="nohighlight hljs"> n =    1 | error = 0.7499
 n =    2 | error = 0.4999
 n =    5 | error = 0.4318
 n =   10 | error = 0.3188
 n =   20 | error = 0.1302
 n =   50 | error = 0.0695
 n =  100 | error = 0.0287
 n =  200 | error = 0.0092
 n =  500 | error = 0.0017
 n = 1000 | error = 0.0004</code></pre><p>See <a href="../API/#GaussianRandomFields.KarhunenLoeve"><code>KarhunenLoeve</code></a> for more.</p><h3 id="Circulant-Embedding"><a class="docs-heading-anchor" href="#Circulant-Embedding">Circulant Embedding</a><a id="Circulant-Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Circulant-Embedding" title="Permalink"></a></h3><p>A Gaussian random field generator that uses an FFT, but is restricted to rectangular structured grids. In this case, the covariance matrix has a Toeplitz structure (<code>d=1</code>), a block Toeplitz structure with Toeplitz blocks (<code>d=2</code>), ... This structure can be exploited by embedding the matrix in a larger circulant matrix, of which the eigenvalues can be computed very efficiently using FFT.</p><p>Here&#39;s the covariance matrix of the exponential covariance function in two dimensions.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, Exponential(1))
pts = range(0, stop=1, length=11)
C = apply(cov, pts, pts)
heatmap(C)</code></pre><p align="center">
<img src="assets/covariance_matrix.jpg" alt="covariance_matrix" style="width:75%" align="middle">
</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>A small catch here is that, although the covariance matrix is positive semi-definite, its circulant extension in general is not.</p></div></div><p>Hence, we must add some <em>ghost points</em> outside the domain of interest using the optional argument padding. If the matrix is not positive definite, an approximated Gaussian random field will still be computed using only the positive eigenvalues of the covariance matrix. Depending on the size of the smallest eigenvalue, this approximation may or may not be useable in practice.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, Exponential(.5))
pts = range(0, stop=1, length=1001)
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, minpadding=2001)
heatmap(grf)</code></pre><img src="assets/exponential_grf.jpg" alt="exponential_grf" style="width:100%"><p>See <a href="../API/#GaussianRandomFields.CirculantEmbedding"><code>CirculantEmbedding</code></a> for more.</p><h2 id="Defining-Custom-Covariance-Functions"><a class="docs-heading-anchor" href="#Defining-Custom-Covariance-Functions">Defining Custom Covariance Functions</a><a id="Defining-Custom-Covariance-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Custom-Covariance-Functions" title="Permalink"></a></h2><p>Defining your own covariance function is easy. Here&#39;s an example using the two-dimensional rotated anisotropic Matérn covariance function.</p><pre><code class="language-julia hljs">using SpecialFunctions # for besselk and gamma

import GaussianRandomFields: shortname, apply

struct RotatedAnisotropicMatern{T} &lt;: AnisotropicCovarianceStructure{T}
    λ::T
    ν::T
    η::T
    θ::T
    σ::T
    p::T
end

RotatedAnisotropicMatern(λ::Real, ν::Real; η::Real=1.0, θ::Real=0, σ::Real=1.0, p::Real=2) =
    RotatedAnisotropicMatern{promote_type(typeof.((λ, ν, η, θ, σ, p))...)}(promote(λ, ν, η, θ, σ, p)...)

shortname(::RotatedAnisotropicMatern) = &quot;rotated anisotropic Matérn&quot;

rot(θ) = [cos(θ) -sin(θ); sin(θ) cos(θ)]

function apply(r::RotatedAnisotropicMatern, x::AbstractVector)
    x_rotated = rot(r.θ * π/180) * x
    ρ = 1/r.λ * sqrt(x_rotated[1]^2/r.η^2 + x_rotated[2]^2)
    if iszero(ρ)
        float(one(ρ))
    else
        2^(1 - r.ν) / gamma(r.ν) * (ρ / r.λ)^r.ν * besselk(r.ν, ρ / r.λ)
    end
end</code></pre><p>This covariance function has two additional parameters, η, the anisotropic ration, and θ, an angle, expressed in degrees. Here are some samples of the random field for different choices of the parameters η and θ.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, RotatedAnisotropicMatern(1/4, 1/2, η=1/16, θ=45))
pts = range(0, stop=1, length=1001)
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts)
heatmap(grf)</code></pre><img src="assets/rotated_anisotropic_matern_grf.jpg" alt="rotated_anisotropic_matern_grf" style="width:100%"><h2 id="Importing-Covariance-Functions-from-KernelFunctions.jl"><a class="docs-heading-anchor" href="#Importing-Covariance-Functions-from-KernelFunctions.jl">Importing Covariance Functions from <code>KernelFunctions.jl</code></a><a id="Importing-Covariance-Functions-from-KernelFunctions.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-Covariance-Functions-from-KernelFunctions.jl" title="Permalink"></a></h2><p>The package <code>KernelFunctions.jl</code> provides a flexible framework for creating covariance functions. We can play nicely with a covariance function defined by <code>KernelFunctions.jl</code> by implementing a <code>KernelWrapper</code> type as follows:</p><pre><code class="language-julia hljs">using KernelFunctions

struct KernelWrapper{K, T} &lt;: IsotropicCovarianceStructure{T} 
    κ::K
    σ::Int
    p::Int
end

KernelWrapper(κ::K) where K &lt;: Kernel = KernelWrapper{K, Float64}(κ, 1, 2)

shortname(::KernelWrapper) = &quot;KernelFunction&quot;

apply(wrapper::KernelWrapper, x::Real) = KernelFunctions.kappa(wrapper.κ, x)</code></pre><p>This allows us to construct a Gaussian random field that uses, for example, the predefined <code>GammaExponentialKernel</code> kernel from <code>KernelFunctions.jl</code>.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(2, KernelWrapper(GammaExponentialKernel(γ=1.5)))
pts = range(0, stop=1, length=100)
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, minpadding=200)
contourf(grf)</code></pre><img src="assets/gamma_exponential_kernel.jpg" alt="gamma_exponential_kernel" style="width:100%"><h2 id="Unstructured-Grids"><a class="docs-heading-anchor" href="#Unstructured-Grids">Unstructured Grids</a><a id="Unstructured-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Unstructured-Grids" title="Permalink"></a></h2><p>Suppose the computational domain is not a rectangular structured grid, but is instead given as a Finite Elements mesh with node table <code>nodes</code> and element table <code>elements</code>. As an example, consider the seven point star-shaped domain defined by <code>star()</code>. Samples of a random field defined on this domain can be computed as follows.</p><pre><code class="language-julia hljs">nodes, elements = star()
cov = CovarianceFunction(2, Matern(0.75, 1))
grf = GaussianRandomField(cov, Cholesky(), nodes, elements)</code></pre><p>To visualize the random field, we can use the function <code>tricontourf</code> from <code>PyPlot.jl</code>.</p><pre><code class="language-julia hljs">using PyPlot</code></pre><pre><code class="language-julia hljs">x = view(nodes, :, 1)
y = view(nodes, :, 2)
tricontourf(x, y, sample(grf), triangles=elements.-1)</code></pre><img src="assets/star.jpg" alt="star" style="width:100%"><h3 id="An-L-shape"><a class="docs-heading-anchor" href="#An-L-shape">An L-shape</a><a id="An-L-shape-1"></a><a class="docs-heading-anchor-permalink" href="#An-L-shape" title="Permalink"></a></h3><p>For meshes with a large number of points, a Gaussian random field constructed using <code>Cholesky()</code> or <code>Spectral()</code> can be expensive. As an alternative, <code>KarhunenLoeve(n)</code> uses a bounding box approach that surrounds the Finite Element mesh.</p><pre><code class="language-julia hljs">nodes, elements = Lshape()
cov = CovarianceFunction(2, Matern(0.75, 1))
grf = GaussianRandomField(cov, KarhunenLoeve(6), nodes, elements)</code></pre><p>The eigenfunctions in the decomposition are now <em>cut out</em> versions of the eigenfunctions defined on the surrounding box.</p><pre><code class="language-julia hljs">x = view(nodes, :, 1)
y = view(nodes, :, 2)
tricontourf(x, y, view(grf.data.eigenfunc, :, n), triangles=elements.-1) # n = 1, 2, ..., 6</code></pre><img src="assets/eigenfunctions_star_kl.jpg" alt="eigenfunctions_star_kl" style="width:100%"><p>If you insist on using the eigenfunctions defined on the Finite Element mesh, use <code>Spectral()</code> with the optional keyword argument <code>n</code> for the number of terms. This uses the <code>eigs</code> solver from <code>Arpack.jl</code>. Remark that these eigenfunctions are now qualitatively different.</p><pre><code class="language-julia hljs">grf = GaussianRandomField(cov, Spectral(), nodes, elements, n=6)</code></pre><pre><code class="language-julia hljs">tricontourf(x, y, view(grf.data.eigenfunc, :, n), triangles=elements.-1) # n = 1, 2, ..., 6</code></pre><img src="assets/eigenfunctions_star_spectral.jpg" alt="eigenfunctions_star_spectral" style="width:100%"><h2 id="More-dimensional-Random-Fields"><a class="docs-heading-anchor" href="#More-dimensional-Random-Fields">More-dimensional Random Fields</a><a id="More-dimensional-Random-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#More-dimensional-Random-Fields" title="Permalink"></a></h2><p>We can define Gaussian random fields in any dimension. Here&#39;s an example with a 5-dimensional random field.</p><pre><code class="language-julia hljs">cov = CovarianceFunction(5, Whittle(.1))
pts = range(0, stop=1, length=11)
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, pts, pts, pts)
sample(grf)</code></pre><h2 id="Separable-Random-Fields"><a class="docs-heading-anchor" href="#Separable-Random-Fields">Separable Random Fields</a><a id="Separable-Random-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Separable-Random-Fields" title="Permalink"></a></h2><p>A popular choice are separable covariance functions, such as the separable exponential covariance function. When the 1-norm is used (<code>p=1</code>), the eigenvalues and eigenfunctions in the KL expansion are known analytically.</p><pre><code class="language-julia hljs">cov = SeparableCovarianceFunction(Exponential(1, p=1), Exponential(1, p=1))
pts = range(0, stop=1, length=1001)
grf = GaussianRandomField(cov, KarhunenLoeve(1000), pts, pts)
heatmap(grf)</code></pre><p>Samples of a separable random field have some visual artifacts.</p><img src="assets/separable_exponential_grf.jpg" alt="separable_exponential_grf" style="width:100%"></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../API/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 28 July 2023 20:31">Friday 28 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
